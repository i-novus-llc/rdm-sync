# Стартер для синхронизации справочников НСИ

## Общая информация

Синхронизатор предоставляет API для запуска копирования справочников НСИ.
Клиент либо сам определяет момент запуска процесса синхронизации, либо включает автоматическое обновление на основе событий публикации справочника (только для RDM).

## Требования к клиентскому приложению

Клиентское приложение:
1) должно быть реализовано на java 14, spring-boot 2 и платформе n2o-platform версии 4.4.0;
2) должно использовать библиотеку Liquibase для автоматического обновления базы данных;
3) должно использовать фреймворк для автоматизации сборки проектов maven3.

## Информация для разработчика

### Подключение

1. Добавить в pom зависимость.
    ```xml
    <dependency>
        <groupId>ru.i-novus.ms.rdm</groupId>
        <artifactId>rdm-sync-spring-boot-starter</artifactId>
        <version>${rdm.sync.version}</version>
    </dependency>
    ```
2. [Настроить маппинг](../README.md#Настройка-маппинга) и создать таблицы для справочников,
   либо воспользоваться [автосозданием](../README.md#Создание-таблиц-клиента-в-автоматическом-режиме).

3. Указать адрес API НСИ в `rdm.client.sync.url`

4. Запустить клиентское приложение.

**Важно:**
Liquibase в rdm-sync запускается ПОСЛЕ общего Liquibase, сконфигурированного по умолчанию.
Поэтому если нужно добавить скрипт, который производит изменения в схеме rdm_sync,
необходимо добавить его в каталог `/rdm-sync-db/changelog`.

После запуска у клиентского приложения будет доступно API:
1. `POST {CLIENT_SERVICE_URL}/rdm/update` -- обновление всех справочников, которые ведутся в системе клиента.
2. `POST {CLIENT_SERVICE_URL}/rdm/update?refbookCode=A001` -- обновление конкретного справочника,
   где A001 -- код справочника.

Для того чтобы отключить синхронизацию полностью, надо указать настройку
- `rdm_sync.enabled=false` (по умолчанию -- включено).

## Синхронизация справочников

### Импорт данных из НСИ

Автоматический импорт данных выполняется по событию публикации справочника.

Требуется наличие брокера сообщений для взаимодействия клиентского приложения и системы НСИ.
Это либо ActiveMQ, реализующий спецификацию JMS 1.1, либо Artemis, реализующий спецификацию JMS 2.0.

В клиентском приложении необходимо:
1. Задать значение свойств `rdm_sync.publish.listener.enable` и `spring.activemq.broker-url`.
   Первое включает (при значении true) возможность импортировать справочник по событию (по умолчанию -- false, т.е. выключено).
   Второе свойство -- это адрес брокера ActiveMQ. Он должен совпадать с адресом брокера, на который уходят сообщения о публикации, т.е с аналогичной настройкой для rdm-rest.

2. Добавить зависимость maven
```xml
<dependency>
   <groupId>org.springframework.boot</groupId>
   <artifactId>spring-boot-starter-activemq</artifactId>
</dependency>
```
или
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-artemis</artifactId>
</dependency>
```
Можно использовать либо JMS 1.1 (ActiveMQ), либо JMS 2.0 (Artemis), т.е. если указываем  `rdm_sync.publish.listener.enable` как `true` -- добавляем зависимости либо от ActiveMQ, либо от Artemis (но не обе!).
В случае с ActiveMQ справочник при событии публикации будет блокироваться (так как спецификация JMS 1.1 не поддерживает механизм SharedSubscription и сообщение о публикации примерно одновременно получат все узлы кластера).
В случае с Artemis блокировок не будет и можно параллельно с синхронизацией модифицировать таблицу со справочником (желательно ограничиться только добавлением записей, которых там точно никогда быть не могло, чтобы избежать конфликтов).

### Экспорт данных в НСИ

Если в вашем приложении есть какая-то сущность, которая отражена в НСИ, вы можете экспортировать её.
Сущности, которые вы синхронизируете с НСИ, должны реализовывать интерфейс `Serializable`. То же самое применяется для всех полей сущности рекурсивно.
Вы можете передать либо экземпляр какой-то конкретной сущности, либо `Map`. В первом случае все поля сущности (вплоть до `Object`-а) будут сложены в `Map` (нерелевантные поля будут отфильтрованы на стороне НСИ).
В НСИ в качестве первичного ключа записи используются идентификаторы, которые вам в общем случае неизвестны, поэтому все операции `Update/Delete` выполняются по первичному ключу **справочника**, который должен быть представлен в вашей сущности.

Базовый интерфейс для данной операции отражён в `ru.i_novus.ms.rdm.sync.service.change_data.RdmChangeDataClient`.
У данного интерфейса есть две реализации: синхронная и асинхронная. Синхронная блокирует вызывающего, асинхронная положит сообщение в очередь и сразу вернёт управление.
Чтобы явно указать синхронную реализацию, необходимо задать для свойства `rdm_sync.change_data.mode` значение `sync`, а чтобы указать асинхронную реализацию -- `async`.
Если свойство `rdm_sync.change_data.mode` не указано, то экспорт данных в НСИ выключен
Если вы решили использовать синхронную реализацию, необходимо убедиться, что вы сконфигурировали брокер сообщений.
Также в classpath должна быть реализация JMS спецификации (например, ActiveMQ).
Результаты и синхронной, и асинхронной операций можно перехватить через `ru.i_novus.ms.rdm.sync.service.change_data.RdmChangeDataRequestCallback` (по умолчанию лог просто пишется в консоль).

Стоит отметить, что в асинхронной реализации контейнер слушателя установлен как транзакционный.
Это значит, что spring-jms не отправит Acknowledge брокеру сообщений в случае, если метод слушателя (помеченный как @JmsListener) кинет исключение.
Поэтому необходимо выставить разумные значения для двух параметров: количество попыток и задержка между ними. Однако в спецификации JMS эти параметры не указаны и настраиваются на стороне брокера.
Например, если у вас Artemis, то в папке `${artemis-broker}/etc` лежит файл `broker.xml`.
В нём есть секция `<address-settings>`. Туда можно добавить `<address-setting>` с `match=jms.queue.${rdm_sync.change_data.queue}` (по умолчанию -- `rdmChangeData`).
Внутри прописываем `<redelivery-delay>DELAY</redelivery-delay>`. В `DELAY` подставляем разумное значение (5 секунд, например) в миллисекундах.
И туда же прописываем `<max-delivery-attempts>ATTEMPTS</max-delivery-attempts>`.
Аналогичные настройки можно найти у других брокеров.

### Обновление данных из НСИ

Возможность обновлять данные в локальной таблице (и со временем в НСИ) является логическим продолжением предыдущей.
Локальные таблицы хранят в себе системное поле, указывающее в каком отношении с соответствующей записью в НСИ находится локальная запись.
Это поле может принимать 4 значения:
1) `SYNCED` -- указывает, что локальная запись была синхронизирована с НСИ и с тех пор не менялась (то есть при условии, что в НСИ не публиковали справочник, эта запись -- корректное отражение её в локальной таблице).
2) `DIRTY` -- указывает, что локальная запись была отредактирована (либо руками, либо программно) и она уже не отражает соответствующую запись в НСИ.
3) `PENDING` -- указывает, что локальная запись была поставлена в очередь на экспорт её в НСИ.
4) `ERROR` -- указывает, что экспорт в НСИ завершился с ошибкой. Это состояние также логически является расширением состояния `DIRTY`.
   Диаграмма переходов состояний, при условии, что запись не модифицируется во время пребывания её в состоянии `PENDING` (что не рекомендуется, иначе можно нарушить порядок доставки в НСИ), выглядит так:
   `SYNCED`→`DIRTY`
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;↑&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;↙
   `PENDING`→`ERROR`
   Также надо отметить, что запись в случае использования асинхронной реализации `ru.i_novus.ms.rdm.sync.service.change_data.RdmChangeDataClient` может остаться в состоянии `PENDING` на неограниченное количество времени.
   Если вы настроили периодическую синхронизацию с НСИ, она со временем перейдёт в `SYNCED` (при условии, что запись с соответствующим первичным ключом присутствует в НСИ).
   Просто стоит помнить, что любое состояние, отличное от `SYNCED`, не отражает реальное положение вещей в НСИ.
   Чтобы узнать состояние записи, необходимо воспользоваться `ru.i_novus.ms.rdm.sync.service.RdmSyncLocalRowStateService`.

## Синхронизация по расписанию

Периодическая синхронизация справочников НСИ реализована с помощью библиотеки Quartz.

Включение/выключение выполнения действий по расписанию задаётся настройкой: `rdm_sync.scheduling` (по умолчанию -- null).
Если настройка имеет значение true, то при подключённом Quartz-шедулере выполняется подготовка и запуск заданий для выполнения требуемых действий.

Управление отдельными действиями (импортом и экспортом) выполняется соответствующими настройками (см. ниже).

### Импорт по расписанию

Для того чтобы гарантировать, что локальные справочники со временем будут идентичны справочникам в НСИ, желательно для них настроить обновление по таймеру.
Желательно сделать это через Quartz-шедулер в кластерном режиме (и пометить Job по обновлению справочников Quartz-аннотацией org.quartz.DisallowConcurrentExecution).
Также cron-выражения нужно выбрать аккуратно, а не так, что у вас допустим 10 справочников и для каждого одно и то же выражение. Лучше распределить импорт этих 10 справочников, например, по часовому интервалу (то есть 6 минут на каждый).
Ручная настройка выполняется так:
1) Автовайрим интерфейс ru.i_novus.ms.rdm.sync.api.service.RdmSyncService через AutowiringSpringBeanJobFactory.
   (по примеру <a href="https://stackoverflow.com/questions/6990767/inject-bean-reference-into-a-quartz-job-in-spring/15211030">отсюда</a>).
2) И в методе org.quartz.Job#execute вызываем его метод ru.i_novus.ms.rdm.sync.api.service.RdmSyncService#update(String refBookCode).
   То есть желательно либо создать по джобу на каждый справочник (со своим cron-ом), либо как-то самим координировать в джобе, чтобы они не запускались разом. Или, если у вас несколько (скажем 3) экземпляров приложения, можно сделать по 3 concurrent джоба одновременно и т.д.

### Экспорт по расписанию

В classpath должен лежать Quartz-шедулер (в кластерном режиме).
Управление экспортом выполняется с помощью настроек: `rdm_sync.export.to_rdm.cron` и `rdm_sync.export.to_rdm.batch_size`.

Библиотека создаст Job, который по крону из настройки `rdm_sync.export.to_rdm.cron` (по умолчанию -- раз в 5 секунд),
будет периодически сканировать все клиентские таблички на предмет записей в состоянии `DIRTY`.
Из этих записей он будет отбирать `rdm_sync.export.to_rdm.batch_size` записей (по умолчанию -- 100) и экспортировать их в RDM.
На каждую пачку записей, отправленную в RDM, внутри RDM будет так же происходить публикация. То есть если у вас 500 "грязных записей" и batch_size = 100, то соответствующий справочник опубликуется 5 раз.
Поэтому batch_size вместе с крон-выражением нужно выбирать аккуратно.
Ещё раз стоит отметить, что очень желательно вместе с экспортом настроить также и импорт.

### Рекомендуемые настройки Quartz

Настройка Quartz-шедулера задаётся параметрами в файле `application.properties`:
```properties
## Spring Quartz
spring.quartz.job-store-type=jdbc

spring.quartz.properties.org.quartz.scheduler.instanceId=AUTO
spring.quartz.properties.org.quartz.scheduler.instanceName=RdmSyncScheduler

# jobStore
spring.quartz.properties.org.quartz.jobStore.class=org.quartz.impl.jdbcjobstore.JobStoreTX
spring.quartz.properties.org.quartz.jobStore.driverDelegateClass=org.quartz.impl.jdbcjobstore.PostgreSQLDelegate
spring.quartz.properties.org.quartz.jobStore.tablePrefix=<schema_name>.<table_prefix>
spring.quartz.properties.org.quartz.jobStore.isClustered=true
```

Здесь значение `spring.quartz.properties.org.quartz.jobStore.tablePrefix` определяется клиентским приложением.
