# Синхронизация справочников НСИ

## Общая информация

Синхронизация справочников предназначена для переноса данных справочников между НСИ и БД клиента синхронизации.
На данный момент в качестве НСИ реализована поддержка RDM и ФНСИ.

Синхронизация справочника реализована в виде библиотеки стартера для spring-boot приложений и в виде отдельного микросервиса.
Клиент синхронизации в своей БД создаёт таблицы соответствующей структуры, в которые будет выполняться копирование данных НСИ.

Синхронизация включает в себя:
- [импорт данных](#Импорт-данных-из-НСИ) справочников из НСИ;
- [экспорт данных](#Экспорт-данных-в-НСИ) справочников в НСИ (только RDM) в синхронном/асинхронном режиме;
- [обновление данных](#Обновление-данных-из-НСИ) справочников из НСИ.

Также добавлена возможность синхронизации [по расписанию](#Синхронизация-по-расписанию).

## Информация для разработчика

### Требования

- OpenJDK 14
- PostgreSQL 11
- Artemis или ActiveMQ

### Стек технологий

- Java 14
- JDBC
- JAX-RS
- JMS
- Spring Boot 2.1
- Spring Cloud Greenwich
- Liquibase 3.6.2
- N2O Platform 4

### Структура проекта

- [rdm-sync-spring-boot-starter](rdm-sync-spring-boot-starter/README.md) - стартер для синхронизации справочников НСИ.
- [rdm-sync-service](rdm-sync-service/README.md) - запускаемый модуль для синхронизации справочников НСИ на основе стартера.

### Настройка синхронизации

```properties
#  Подключение к БД
spring.datasource.url=jdbc:postgresql://localhost:5432/rdm_sync
spring.datasource.username=postgres
spring.datasource.password=postgres

# Адрес API RDM'a (если не нужна синхронизация с RDM, то указывать не надо)
rdm.backend.path=http://yandex.stable:9904/rdm/service/rdm/api

# Адрес API ФНСИ (если не нужна синхронизация с ФНСИ, то указывать не надо)
rdm_sync.fnsi.url=https://fnsi-dev.rt-eu.ru/port
# Ключ для API ФНСИ (если не нужна синхронизация с ФНСИ, то указывать не надо)
rdm_sync.fnsi.userKey=4191f0cf-b100-4d80-a392-6cee9432deea
```

#### Полный список настроек

Настройка|Значение по умолчанию|Описание|
|---|---|---|
|rdm.backend.path| -| Адрес API RDM'a |
|rdm_sync.auto_create.schema| rdm| Схема, в которой будут создаваться таблицы в режиме автосоздания|
|rdm_sync.scheduling| true| Запуск по расписанию, true -- включено|
|rdm_sync.import.from_rdm.cron| 0 * * * * ?| Крон для загрузки данных из НСИ|
|rdm_sync.export.to_rdm.cron| 0 * * * * ?| Крон для загрузки данных в НСИ (только для RDM)|
|rdm-sync.load.size| 1000| Кол-во записей на странице при получении данных из НСИ|
|rdm.sync.threads.coun| 1| Кол-во потоков в пуле на синхронизацию справочников. Один поток выделяется на один справочник|

### Описание таблиц

В базе данных создаётся схема `rdm_sync` с таблицами:
- `refbook` -- список справочников, которые необходимо синхронизировать;
- `version` -- список версий справочников;
- `mapping` -- маппинг версий справочников;
- `field_mapping` -- список полей при маппинге;
- `loaded_version` -- список загруженных версий справочников;
- `log` -- журнал обновления.

## Настройка маппинга

**Маппинг** -- это соответствие полей справочника в системе НСИ и колонок таблицы в БД клиента.
Описание маппинга задаётся в таблице `rdm_sync.field_mapping` (см. комментарии к колонкам).
Описание, какой справочник копировать в какую таблицу, задаётся в таблице `rdm_sync.version`.

### XML-конфигурация маппинга

Маппинг можно настроить через XML-конфигурацию.
В classpath (например, в папку resources) создаём файл с наименованием *rdm-mapping.xml*.
В случае изменения маппинга меняем в файле соответствующий элемент refbook и увеличиваем mapping-version на 1.

Пример:
```xml
<?xml version="1.0" encoding="UTF-8" ?>
<mapping>

    <refbook code="T001" sys-table="rdm.test_rb" unique-sys-field="code" deleted-field="is_deleted" mapping-version="1">
        <field sys-field="code" sys-data-type="varchar" rdm-field="id"/>
        <field sys-field="name" sys-data-type="varchar" rdm-field="short_name"/>
        <field sys-field="doc_number" sys-data-type="integer" rdm-field="doc_num"/>
    </refbook>

    <refbook code="R001" sys-table="rdm.some_table" unique-sys-field="code" deleted-field="is_deleted" mapping-version="1">
        <field sys-field="code" sys-data-type="varchar" rdm-field="id"/>
        <field sys-field="name" sys-data-type="varchar" rdm-field="short_name"/>
    </refbook>

</mapping>
```

**Важно:**

Маппинг должен соответствовать тому справочнику, который есть в НСИ и в клиентском приложении.
То есть в маппинге должны быть только поля, которые существуют как в НСИ, так и в локальной таблице.

### Автогенерация XML-конфигурации

Для облегчения разработки предусмотрена генерация файла `rdm-mapping.xml` по существующим записям в БД.

1. Указываете настройки `rdm_sync.auto_create.refbook_codes` и `rdm_sync.auto_create.schema`.
2. Запускаете своё приложение. Стартер скачает справочники из НСИ и создаст таблицы.
3. Получаете сгенерированный файл `rdm-mapping.xml` по адресу `<адрес вашего приложения>/api/rdm/xml-fm?code=REF_BOOK_CODE1&code=REF_BOOK_CODE2&...`
4. Полученный файл `rdm-mapping.xml` можно поправить и положить в classpath уже для использования по назначению.
   Например, можно убрать неиспользуемые поля справочника.

Вы также можете перейти по адресу `localhost:8080/api/rdm/xml-fm?code=all`.
Так вы получите файл, в котором перечислен маппинг для каждого справочника, ведущегося в вашем приложении.

## Ограничения маппинга

- Справочники без первичных ключей не смогут синхронизироваться.
- Строковый тип из НСИ можно маппить в "varchar", "text", "character varying", "smallint", "integer", "bigint", "serial", "bigserial", boolean(true/false), "numeric", "decimal",  "date(yyyy-MM-dd)".
- Дату из НСИ можно  маппить в "date", "varchar", "text", "character varying".
- Дробный из НСИ можно маппить в "numeric", "decimal", "varchar", "text", "character varying".
- Логический тип из НСИ можно маппить в boolean, "varchar", "text", "character varying".

## Создание таблиц

**Важно:**
Синхронизация не создаёт таблиц для копирования данных из НСИ, это должно делать само клиентское приложение.

### Создание таблиц вручную

Таблицы создавать в схеме rdm.
Таблица должна содержать технические колонки:
- `UUID id` -- внутренний первичный ключ таблицы, на него можно ссылаться внутри системы.
- `code` -- колонка с любым типом, совместимым с типом первичного ключа справочника НСИ.

  В эту колонку будет копироваться значение первичного ключа справочника из НСИ. Указывается в колонке `rdm_sync.version.unique_sys_field`.
- `is_deleted` -- признак удалённости записи. Указывается в колонке `rdm_sync.version.deleted_field`.

Таблица должна содержать колонки для значений справочника, т.е. те колонки, в которые будут копироваться данные из полей справочника.
Их количество и название необязательно должны совпадать.
Эти колонки участвуют в маппинге, т.е. прописываются в `rdm_sync.field_mapping`.

### Создание таблиц в автоматическом режиме

Вам необходимо указать две настройки: `rdm_sync.auto_create.schema` и `rdm_sync.auto_create.refbook_codes`.
Первая указывает на то, в какой схеме будет создана таблица клиента (по умолчанию -- `rdm`). Если схемы нет, она также будет создана.
Вторая задаётся в формате `code1,code2,...,codeN`. Это коды справочников, для которых автоматом создадутся таблицы. Название таблицы будет кодом справочника, переведённым в нижний регистр, с символами `-` и `.`, заменёнными на `_`.
Вы также можете настроить создание таблиц с учётом маппинга. Таблицы создадутся уже не по структуре справочника из RDM, а по вашему маппингу.
Важно отметить, что таблицы только создаются. Она не подхватывает на лету изменения версий `rdm-mapping.xml` и изменения версий справочников в RDM.

## Синхронизация справочников НСИ

### Импорт данных из НСИ

Автоматический импорт данных выполняется по событию публикации справочника.

Требуется наличие брокера сообщений для взаимодействия клиентского приложения и системы НСИ.
Это либо ActiveMQ, реализующий спецификацию JMS 1.1, либо Artemis, реализующий спецификацию JMS 2.0.

В клиентском приложении необходимо:
1. Задать значение свойств `rdm_sync.publish.listener.enable` и `spring.activemq.broker-url`.
   Первое включает (при значении true) возможность импортировать справочник по событию (по умолчанию -- false, т.е. выключено).
   Второе свойство -- это адрес брокера ActiveMQ. Он должен совпадать с адресом брокера, на который уходят сообщения о публикации, т.е с аналогичной настройкой для rdm-rest.

2. Добавить зависимость maven
```xml
<dependency>
   <groupId>org.springframework.boot</groupId>
   <artifactId>spring-boot-starter-activemq</artifactId>
</dependency>
```
или
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-artemis</artifactId>
</dependency>
```
Можно использовать либо JMS 1.1 (ActiveMQ), либо JMS 2.0 (Artemis), т.е. если указываем  `rdm_sync.publish.listener.enable` как `true` -- добавляем зависимости либо от ActiveMQ, либо от Artemis (но не обе!).
В случае с ActiveMQ справочник при событии публикации будет блокироваться (так как спецификация JMS 1.1 не поддерживает механизм SharedSubscription и сообщение о публикации примерно одновременно получат все узлы кластера).
В случае с Artemis блокировок не будет и можно параллельно с синхронизацией модифицировать таблицу со справочником (желательно ограничиться только добавлением записей, которых там точно никогда быть не могло, чтобы избежать конфликтов).

### Экспорт данных в НСИ

Если в вашем приложении есть какая-то сущность, которая отражена в НСИ, вы можете экспортировать её.
Сущности, которые вы синхронизируете с НСИ, должны реализовывать интерфейс `Serializable`. То же самое применяется для всех полей сущности рекурсивно.
Вы можете передать либо экземпляр какой-то конкретной сущности, либо `Map`. В первом случае все поля сущности (вплоть до `Object`-а) будут сложены в `Map` (нерелевантные поля будут отфильтрованы на стороне НСИ).
В НСИ в качестве первичного ключа записи используются идентификаторы, которые вам в общем случае неизвестны, поэтому все операции `Update/Delete` выполняются по первичному ключу **справочника**, который должен быть представлен в вашей сущности.

Базовый интерфейс для данной операции отражён в `ru.i_novus.ms.rdm.sync.service.change_data.RdmChangeDataClient`.
У данного интерфейса есть две реализации: синхронная и асинхронная. Синхронная блокирует вызывающего, асинхронная положит сообщение в очередь и сразу вернёт управление.
Чтобы явно указать синхронную реализацию, необходимо задать для свойства `rdm_sync.change_data.mode` значение `sync`, а чтобы указать асинхронную реализацию -- `async`.
Если свойство `rdm_sync.change_data.mode` не указано, то экспорт данных в НСИ выключен
Если вы решили использовать синхронную реализацию, необходимо убедиться, что вы сконфигурировали брокер сообщений.
Также в classpath должна быть реализация JMS спецификации (например, ActiveMQ).
Результаты и синхронной, и асинхронной операций можно перехватить через `ru.i_novus.ms.rdm.sync.service.change_data.RdmChangeDataRequestCallback` (по умолчанию лог просто пишется в консоль).

Стоит отметить, что в асинхронной реализации контейнер слушателя установлен как транзакционный.
Это значит, что spring-jms не отправит Acknowledge брокеру сообщений в случае, если метод слушателя (помеченный как @JmsListener) кинет исключение.
Поэтому необходимо выставить разумные значения для двух параметров: количество попыток и задержка между ними. Однако в спецификации JMS эти параметры не указаны и настраиваются на стороне брокера.
Например, если у вас Artemis, то в папке `${artemis-broker}/etc` лежит файл `broker.xml`.
В нём есть секция `<address-settings>`. Туда можно добавить `<address-setting>` с `match=jms.queue.${rdm_sync.change_data.queue}` (по умолчанию -- `rdmChangeData`).
Внутри прописываем `<redelivery-delay>DELAY</redelivery-delay>`. В `DELAY` подставляем разумное значение (5 секунд, например) в миллисекундах.
И туда же прописываем `<max-delivery-attempts>ATTEMPTS</max-delivery-attempts>`.
Аналогичные настройки можно найти у других брокеров.

### Обновление данных из НСИ

Возможность обновлять данные в локальной таблице (и со временем в НСИ) является логическим продолжением предыдущей.
Локальные таблицы хранят в себе системное поле, указывающее в каком отношении с соответствующей записью в НСИ находится локальная запись.
Это поле может принимать 4 значения:
1) `SYNCED` -- указывает, что локальная запись была синхронизирована с НСИ и с тех пор не менялась (то есть при условии, что в НСИ не публиковали справочник, эта запись -- корректное отражение её в локальной таблице).
2) `DIRTY` -- указывает, что локальная запись была отредактирована (либо руками, либо программно) и она уже не отражает соответствующую запись в НСИ.
3) `PENDING` -- указывает, что локальная запись была поставлена в очередь на экспорт её в НСИ.
4) `ERROR` -- указывает, что экспорт в НСИ завершился с ошибкой. Это состояние также логически является расширением состояния `DIRTY`.
   Диаграмма переходов состояний, при условии, что запись не модифицируется во время пребывания её в состоянии `PENDING` (что не рекомендуется, иначе можно нарушить порядок доставки в НСИ), выглядит так:
   `SYNCED`→`DIRTY`
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;↑&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;↙
   `PENDING`→`ERROR`
   Также надо отметить, что запись в случае использования асинхронной реализации `ru.i_novus.ms.rdm.sync.service.change_data.RdmChangeDataClient` может остаться в состоянии `PENDING` на неограниченное количество времени.
   Если вы настроили периодическую синхронизацию с НСИ, она со временем перейдёт в `SYNCED` (при условии, что запись с соответствующим первичным ключом присутствует в НСИ).
   Просто стоит помнить, что любое состояние, отличное от `SYNCED`, не отражает реальное положение вещей в НСИ.
   Чтобы узнать состояние записи, необходимо воспользоваться `ru.i_novus.ms.rdm.sync.service.RdmSyncLocalRowStateService`.

## Синхронизация по расписанию

Синхронизация справочников НСИ реализована с помощью библиотеки Quartz.

Включение/выключение выполнения действий по расписанию задаётся настройкой: `rdm_sync.scheduling` (по умолчанию -- null).
Если настройка имеет значение true, то при подключённом Quartz-шедулере выполняется подготовка и запуск заданий для выполнения требуемых действий.

Управление отдельными действиями (импортом и экспортом) выполняется соответствующими настройками (см. ниже).

### Настройка Quartz-шедулера

Настройка Quartz-шедулера задаётся параметрами в файле `application.properties`:
```properties
## Spring Quartz
spring.quartz.job-store-type=jdbc
spring.quartz.jdbc.initialize-schema=never

spring.quartz.properties.org.quartz.scheduler.instanceId=AUTO
spring.quartz.properties.org.quartz.scheduler.instanceName=RdmSyncScheduler

# jobStore
spring.quartz.properties.org.quartz.jobStore.class=org.quartz.impl.jdbcjobstore.JobStoreTX
spring.quartz.properties.org.quartz.jobStore.driverDelegateClass=org.quartz.impl.jdbcjobstore.PostgreSQLDelegate
spring.quartz.properties.org.quartz.jobStore.tablePrefix=${rdm.sync.liquibase.param.quartz_schema_name}.${rdm.sync.liquibase.param.quartz_table_prefix}
spring.quartz.properties.org.quartz.jobStore.isClustered=true
```

Здесь:
- `rdm.sync.liquibase.param.quartz_schema_name` -- наименование схемы, в которой находятся или будут созданы таблицы Quartz.
- `rdm.sync.liquibase.param.quartz_table_prefix` -- префикс, используемый при наименовании таблиц Quartz.

### Настройка периодического импорта справочников

Для того чтобы гарантировать, что локальные справочники со временем будут идентичны справочникам в НСИ, желательно для них настроить обновление по таймеру.
Желательно сделать это через Quartz-шедулер в кластерном режиме (и пометить Job по обновлению справочников Quartz-аннотацией org.quartz.DisallowConcurrentExecution).
Также cron-выражения нужно выбрать аккуратно, а не так, что у вас допустим 10 справочников и для каждого одно и то же выражение. Лучше распределить импорт этих 10 справочников, например, по часовому интервалу (то есть 6 минут на каждый).
Ручная настройка выполняется так:
1) Автовайрим интерфейс ru.i_novus.ms.rdm.sync.api.service.RdmSyncService через AutowiringSpringBeanJobFactory.
   (по примеру <a href="https://stackoverflow.com/questions/6990767/inject-bean-reference-into-a-quartz-job-in-spring/15211030">отсюда</a>).
2) И в методе org.quart.Job#execute вызываем его метод ru.i_novus.ms.rdm.sync.api.service.RdmSyncService#update(String refBookCode).
   То есть желательно либо создать по джобу на каждый справочник (со своим cron-ом), либо как-то самим координировать в джобе, чтобы они не запускались разом. Или, если у вас несколько (скажем 3) экземпляров приложения, можно сделать по 3 concurrent джоба одновременно и т.д.

### Настройка периодического экспорта справочников

В classpath должен лежать Quartz-шедулер (в кластерном режиме).
Управление экспортом выполняется с помощью настроек: `rdm_sync.export.to_rdm.cron` и `rdm_sync.export.to_rdm.batch_size`.

Библиотека создаст Job, который по крону, заданному настройкой `rdm_sync.export.to_rdm.cron` (по умолчанию -- раз в 5 секунд),
будет периодически сканировать все клиентские таблички на предмет записей в состоянии `DIRTY`.
Из этих записей он будет отбирать `rdm_sync.export.to_rdm.batch_size` записей (по умолчанию -- 100) и экспортировать их в RDM.
На каждую пачку записей, отправленную в RDM, внутри RDM будет так же происходить публикация. То есть если у вас 500 "грязных записей" и batch_size = 100, то соответствующий справочник опубликуется 5 раз.
Поэтому batch_size вместе с крон-выражением нужно выбирать аккуратно.
Ещё раз стоит отметить, что очень желательно вместе с экспортом настроить также и импорт.
